# -*- coding: utf-8 -*-
"""heart_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SdANWkrFIaO8avrZ_go-YhkK_Xmkyi30
"""

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchsummary
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

"""###Dataset

"""

dataset = pd.read_csv('heart.csv')
dataset.head()

"""###Visualize data"""

plt.figure(figsize=(10, 6))
plt.scatter(dataset['age'], dataset['cp'], c=dataset['slp'], cmap=plt.cm.RdYlBu)
plt.colorbar(label='Slope')
plt.title('Age vs Chest Pain Type')
plt.xlabel('Age')
plt.ylabel('Chest Pain Type')
plt.show()

"""###Covert data to numpy Arrays"""

dataset

X_array = dataset.iloc[:, :-1].values
y_array = dataset.iloc[:, -1].values

X_array[:10], y_array[:10]

"""###Convert numpy array to tensors"""

X = torch.tensor(X_array, dtype=torch.float32)
y = torch.tensor(y_array, dtype=torch.float32)

X[:10], y[:10]

"""###check the input output shapes"""

X.shape, y.shape

"""###split train and test data"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

len(X_train), len(X_test), len(y_train), len(y_test)

"""###build model"""

device = 'cuda' if torch.cuda.is_available() else 'cpu'
device

class model(nn.Module):
  def __init__(self):
    super().__init__()
    self.layer1 = nn.Linear(13, 100)
    self.layer2 = nn.Linear(100, 100)
    self.layer3 = nn.Linear(100, 100)
    self.layer4 = nn.Linear(100, 50)
    self.layer5 = nn.Linear(50, 1)

  def forward(self, x):
    return self.layer5(self.layer4(self.layer3(self.layer2(self.layer1(x)))))

model = model().to(device)

"""##Model summary"""

modelsummary = torchsummary.summary(model, (1, 13))

"""###loss fumction and optimizer"""

loss_fn = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.002)

def accuracy_fn(y_true, y_pred):
  correct = torch.eq(y_true, y_pred).sum().item()
  acc = (correct/len(y_pred)) * 100
  return acc

"""###**training** loop"""

epochs = 1000

X_train = X_train.to(device)
X_test = X_test.to(device)
y_train = y_train.to(device)
y_test = y_test.to(device)

for epoch in range(epochs):

  #training
  model.train()

  y_logits = model(X_train).squeeze()
  y_pred = torch.round(torch.sigmoid(y_logits))

  loss = loss_fn(y_logits, y_train)
  acc = accuracy_fn(y_train, y_pred)

  optimizer.zero_grad()

  loss.backward()

  optimizer.step()

  #tesing
  model.eval()

  with torch.inference_mode():
    test_logits = model(X_test).squeeze()
    test_pred = torch.round(torch.sigmoid(test_logits))

    test_loss = loss_fn(test_logits, y_test)
    test_acc = accuracy_fn(y_test, test_pred)


  if epoch % 10 == 0:
    print(f"epoch: {epoch} | training:- loss: {loss}  acc: {acc} | testing:- loss: {test_loss}  acc: {test_acc} ")

"""###save model"""

modelfilename = "model"
torch.save(obj=model.state_dict(), f=modelfilename)